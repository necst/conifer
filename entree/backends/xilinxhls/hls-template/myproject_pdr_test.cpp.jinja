// Copyright 2022 Novel, Emerging Computing System Technologies Laboratory 
//                (NECSTLab), Politecnico di Milano

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
//    rfnoc-hls-neuralnet: Vivado HLS code for neural-net building blocks
//
//    Copyright (C) 2017 EJ Kreinar
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <fstream>
#include <iostream>
#include <algorithm>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "firmware/{{projectname}}.h"
#include "firmware/parameters.h"
#include "firmware/BDT.h"

#define CHECKPOINT 5000

template<typename packet_t, int in_count, int out_count>
void axis_crossbar(
	hls::stream<packet_t> in[in_count],
	hls::stream<packet_t> out[out_count]
) {
	for (unsigned int i = 0; i < in_count; i++) {
		while (!in[i].empty()) {
			packet_t pkt;
			in[i] >> pkt;

			if (in_count > 1) {
				// N:1?
				unsigned int dest = 0;

				if (out_count > 1) {
					// N:M
					dest = pkt.dest;
				}

				if (dest > out_count) {
					std::cout << "Unable to route axis packet from stream " << i << " to stream " << dest << std::endl;
					continue;
				}

				out[dest] << pkt;
			} else {
				// 1:N
				for (unsigned int j = 0; j < out_count; j++) {
					out[j] << pkt;
				}
			}
		}
	}
}

template<typename pkt_t, typename data_t>
data_t tee(hls::stream<pkt_t> &in, hls::stream<pkt_t> &out) {
	pkt_t pkt;

	in >> pkt;
	out << pkt;

	return pkt.data;
}

int main(int argc, char **argv)
{
  //load input data from text file
  std::ifstream fin("tb_data/tb_input_features.dat");

#ifdef RTL_SIM
  std::string RESULTS_LOG = "tb_data/cosim_results.log";
  std::string VERBOSE_LOG = "tb_data/cosim_tree_results.log";
#else
  std::string RESULTS_LOG = "tb_data/csim_results.log";
  std::string VERBOSE_LOG = "tb_data/csim_tree_results.log";
#endif
  std::ofstream fout(RESULTS_LOG);
  std::ofstream ftrees(VERBOSE_LOG);

  std::string iline;
  std::string pline;
  int e = 0;

  if (fin.is_open()) {
    static hls::stream<input_arr_s_t> sample_stream[1];
    static hls::stream<bank_command_s_t> bank_command_stream[1];
    static hls::stream<input_arr_s_t> bank_stream[bank_count];
    static hls::stream<input_arr_s_t> tree_stream[n_trees * n_classes];
    static hls::stream<tree_score_s_t> aux_score_stream[n_trees * n_classes];
    static hls::stream<tree_score_s_t> score_stream[n_trees * n_classes];
    static hls::stream<tree_score_s_t> in_class_stream[n_classes];
    static hls::stream<class_score_s_t> out_class_stream[n_classes];

    int curr_id = max_parallel_samples - 1;

    while ( std::getline(fin,iline) ) {
      if (e % CHECKPOINT == 0) std::cout << "Processing input " << e << std::endl;
      e++;
      char* cstr=const_cast<char*>(iline.c_str());
      char* current;
      std::vector<float> in;
      current=strtok(cstr," ");
      while(current!=NULL) {
        in.push_back(atof(current));
        current=strtok(NULL," ");
      }

      input_arr_s_t in_pkt;
      //hls-fpga-machine-learning insert data
      std::vector<float>::const_iterator in_begin = in.cbegin(); 
      std::vector<float>::const_iterator in_end;
      input_arr_t x;
      in_end = in_begin + ({{n_features}});
      {%- if not cfg_get %}
      std::copy(in_begin, in_end, x);
      {%- else %}
      std::copy(in_begin, in_end, in_pkt.data);
      {%- endif %}
      in_begin = in_end;
      {#- brace-init zeros the array out because we use std=c++0x #}
      score_arr_t score{};
      score_t tree_scores[BDT::fn_classes(n_classes) * n_trees]{};
      {#- but we can still explicitly zero out if you want #}
      std::fill_n(score, {{n_classes}}, 0.);
      {%- if cfg_get %}
      sample_stream[0] << in_pkt;
      {%- endif %}
      curr_id = (curr_id + 1) % max_parallel_samples;
      in_pkt.id = curr_id;

      //hls-fpga-machine-learning insert top-level-function 
      {%- if not cfg_get %} 
{{indent}}    {{projectname}}(x, score/*, tree_scores*/);
      {%- else %}
          {#- // TODO: Use all the bank buffers and test reconfiguration #}
          {#- // TODO: Use vote buffers #}
{{indent}}      bank_command_s_t command_pkt;
{{top_level}}      {{inent}}command_pkt.data = 0b00111111;
{{top_level}}      {{inent}}command_pkt.dest = 0;
{{top_level}}      {{inent}}bank_command_stream[0] << command_pkt;
{{top_level}}      {{inent}}{{projectname}}__bank_buffer_1(sample_stream[0], bank_stream[0], bank_command_stream[0]);
{{top_level}}      {{inent}}axis_crossbar<input_arr_s_t, 1, n_trees * n_classes>(bank_stream, tree_stream);
          {%- for tree_ip in tree_ips %}
{{indent}}      {{projectname}}__tree_cl{{tree_ip.iclass}}_{{tree_ip.itree}}(tree_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}], aux_score_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}]);
{{indent}}      tree_scores[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}] = tee<tree_score_s_t, score_t>(aux_score_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}], score_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}]);        
          {%- endfor %}
{{indent}}      axis_crossbar<tree_score_s_t, n_trees * n_classes, n_classes>(score_stream, in_class_stream);
          {%- for iclass in range(class_count) %}
{{indent}}      while(!in_class_stream[{{iclass}}].empty()) {
{{indent}}        {{projectname}}__voting_station_cl{{iclass}}(in_class_stream[{{iclass}}], out_class_stream[{{iclass}}]);
{{indent}}      }
          {%- endfor %}
      {%- endif %}
  
      for(int  i = 0; i < n_trees; i++){
          for(int j = 0; j < BDT::fn_classes(n_classes); j++){
            ftrees << tree_scores[i * BDT::fn_classes(n_classes) + j] << " ";
          }
      }
      ftrees << std::endl;
    }

    for (int i = 0; i < BDT::fn_classes(n_classes); i++) {
    	tree_score_s_t pkt;
		  pkt.last = true;
    	in_class_stream[i] << pkt;
    }

    //hls-fpga-machine-learning insert final-round
    {%- if cfg_get %}
        {%- for iclass in range(class_count) %}
{{indent}}    {{projectname}}__voting_station_cl{{iclass}}(in_class_stream[{{iclass}}], out_class_stream[{{iclass}}]);
        {%- endfor%}
    {%- endif%}
  
    while(
      //hls-fpga-machine-learning insert stream-check
      {%- if cfg_get %}
{{indent}}{{'      '}}      
          {%- for iclass in range(class_count) -%}
 !out_class_stream[{{iclass}}].empty(){% if loop.last %}{% else %} && {% endif %}
          {%- endfor %}
      {%- endif %}
    ) {

      for(int i = 0; i < BDT::fn_classes(n_classes); i++){
        class_score_s_t score;
        if (!out_class_stream[i].empty()) {
          out_class_stream[i] >> score;
          fout << score.data << " ";
        } else {
          fout << "NaN ";
        }
      }
      fout << std::endl;
    }

    fin.close();
  } else {
    std::cout << "CRITICAL: Unable to open input file." << std::endl;
	  return -1;
  }

  fout.close();
  ftrees.close();
  std::cout << "INFO: Saved inference results to file: " << RESULTS_LOG << std::endl;

  return 0;
}
