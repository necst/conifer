// Copyright 2022 Novel, Emerging Computing System Technologies Laboratory 
//                (NECSTLab), Politecnico di Milano

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
//    rfnoc-hls-neuralnet: Vivado HLS code for neural-net building blocks
//
//    Copyright (C) 2017 EJ Kreinar
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <fstream>
#include <iostream>
#include <algorithm>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

{{'#include "firmware/%s.h"'|format(projectname)}}
#include "firmware/parameters.h"
#include "firmware/BDT.h"

#define CHECKPOINT 5000

template<typename packet_t, int in_count, int out_count>
void axis_crossbar(
	hls::stream<packet_t> in[in_count],
	hls::stream<packet_t> out[out_count]
) {
	for (unsigned int i = 0; i < in_count; i++) {
		while (!in[i].empty()) {
			packet_t pkt;
			in[i] >> pkt;

			if (in_count > 1) {
				// N:1?
				unsigned int dest = 0;

				if (out_count > 1) {
					// N:M
					dest = pkt.dest;
				}

				if (dest > out_count) {
					std::cout << "Unable to route axis packet from stream " << i << " to stream " << dest << std::endl;
					continue;
				}

				out[dest] << pkt;
			} else {
				// 1:N
				for (unsigned int j = 0; j < out_count; j++) {
					out[j] << pkt;
				}
			}
		}
	}
}

template<typename pkt_t, typename data_t>
data_t tee(hls::stream<pkt_t> &in, hls::stream<pkt_t> &out) {
	pkt_t pkt;

	in >> pkt;
	out << pkt;

	return pkt.data;
}

int main(int argc, char **argv)
{
  //load input data from text file
  std::ifstream fin("tb_data/tb_input_features.dat");

#ifdef RTL_SIM
  std::string RESULTS_LOG = "tb_data/cosim_results.log";
  std::string VERBOSE_LOG = "tb_data/cosim_tree_results.log";
#else
  std::string RESULTS_LOG = "tb_data/csim_results.log";
  std::string VERBOSE_LOG = "tb_data/csim_tree_results.log";
#endif
  std::ofstream fout(RESULTS_LOG);
  std::ofstream ftrees(VERBOSE_LOG);

  std::string iline;
  std::string pline;
  int e = 0;

  if (fin.is_open()) {
    static hls::stream<input_arr_s_t> sample_stream[1];
    static hls::stream<bank_command_s_t> bank_command_stream[1];
    static hls::stream<input_arr_s_t> bank_stream[bank_count];
    static hls::stream<input_arr_s_t> tree_stream[n_trees * n_classes];
    static hls::stream<tree_score_s_t> aux_score_stream[n_trees * n_classes];
    static hls::stream<tree_score_s_t> score_stream[n_trees * n_classes];
    static hls::stream<tree_score_s_t> in_class_stream[n_classes];
    static hls::stream<class_score_s_t> out_class_stream[n_classes];

    int curr_id = max_parallel_samples - 1;

    while ( std::getline(fin,iline) ) {
      if (e % CHECKPOINT == 0) std::cout << "Processing input " << e << std::endl;
      e++;
      char* cstr=const_cast<char*>(iline.c_str());
      char* current;
      std::vector<float> in;
      current=strtok(cstr," ");
      while(current!=NULL) {
        in.push_back(atof(current));
        current=strtok(NULL," ");
      }

      input_arr_s_t in_pkt;
      {%- set newline = '//hls-fpga-machine-learning insert data\n' %}
      {%- set newline ="%s      std::vector<float>::const_iterator in_begin = in.cbegin(); \n"|format(newline) %}
      {%- set newline ="%s      std::vector<float>::const_iterator in_end;\n"|format(newline) %}
      {%- set newline ="%s      input_arr_t x;\n"|format(newline) %}
      {%- set newline ="%s      in_end = in_begin + (%d);\n"|format(newline,n_features) %}
      {%- if not cfg_get %}
          {%- set newline ="%s      std::copy(in_begin, in_end, x);\n"|format(newline) %}
      {%- else %}
          {%- set newline ="%s      std::copy(in_begin, in_end, in_pkt.data);\n"|format(newline) %}
      {%- endif %}
      {%- set newline ="%s      in_begin = in_end;\n"|format(newline) %}
      {#- brace-init zeros the array out because we use std=c++0x #}
      {%- set newline ="%s      score_arr_t score{};\n"|format(newline) %}
      {%- set newline ="%s      score_t tree_scores[BDT::fn_classes(n_classes) * n_trees]{};\n"|format(newline) %}
      {#- but we can still explicitly zero out if you want #}
      {%- set newline ="%s      std::fill_n(score, %d, 0.);\n"|format(newline,n_classes) %}
      {%- if cfg_get %}
          {%- set newline ="%s      sample_stream[0] << in_pkt;"|format(newline) %}
      {%- endif %}
      {{newline}}
      curr_id = (curr_id + 1) % max_parallel_samples;
      in_pkt.id = curr_id; {{"\n"}}

      {%- set newline = '//hls-fpga-machine-learning insert top-level-function \n' %}
      {%- if not cfg_get %} 
          {%- set top_level = "%s    %s(x, score/*, tree_scores*/);\n"|format(intent,projectname) %}
      {%- else %}
          {#- // TODO: Use all the bank buffers and test reconfiguration #}
          {#- // TODO: Use vote buffers #}
          {%- set top_level = "%s     bank_command_s_t command_pkt;\n"|format(intent) %}
          {%- set top_level = "%s      %scommand_pkt.data = 0b00111111;\n"|format(top_level,intent) %}
          {%- set top_level = "%s      %scommand_pkt.dest = 0;\n"|format(top_level,intent) %}
          {%- set top_level = "%s      %sbank_command_stream[0] << command_pkt;\n"|format(top_level,intent) %}
          {%- set top_level = "%s      %s%s__bank_buffer_1(sample_stream[0], bank_stream[0], bank_command_stream[0]);\n"|format(top_level,intent,projectname) %}
          {%- set top_level = "%s      %saxis_crossbar<input_arr_s_t, 1, n_trees * n_classes>(bank_stream, tree_stream);\n"|format(top_level,intent) %}
          {%- set ns = namespace(top_level=top_level) %}
          {%- for tree_ip in tree_ips %}
            {%- set ns.top_level %}
{{- ns.top_level}}    {{intent}}  {{projectname}}__tree_cl{{tree_ip.iclass}}_{{tree_ip.itree}}(tree_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}], aux_score_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}]);{{"\n"}}
    {{-intent}}      tree_scores[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}] = tee<tree_score_s_t, score_t>(aux_score_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}], score_stream[{{tree_ip.itree}} * n_classes + {{tree_ip.iclass}}]); {{"\n"}}
            {%- endset %}                
          {%- endfor %}
          {%- set top_level = "%s %s     axis_crossbar<tree_score_s_t, n_trees * n_classes, n_classes>(score_stream, in_class_stream);\n"|format(ns.top_level,intent) %}
          {%- set ns = namespace(top_level=top_level) %}
          {%- for iclass in range(class_count) %}
              {%- set ns.top_level = "%s %s     while(!in_class_stream[%d].empty()) {\n"|format(ns.top_level,intent,iclass) %}
              {%- set ns.top_level = "%s %s       %s__voting_station_cl%d(in_class_stream[%d], out_class_stream[%d]);\n"|format(ns.top_level,intent,projectname,iclass,iclass,iclass) %}
              {%- set ns.top_level = "%s %s     }\n"|format(ns.top_level,intent) %}
          {%- endfor %}
      {%- endif %}
      {%- set newline="%s %s"|format(newline,ns.top_level) %}
      {{newline}}
      for(int  i = 0; i < n_trees; i++){
          for(int j = 0; j < BDT::fn_classes(n_classes); j++){
            ftrees << tree_scores[i * BDT::fn_classes(n_classes) + j] << " ";
          }
      }
      ftrees << std::endl;
    }

    for (int i = 0; i < BDT::fn_classes(n_classes); i++) {
    	tree_score_s_t pkt;
		  pkt.last = true;
    	in_class_stream[i] << pkt;
    }{{"\n"}}

    {%- set ns=namespace(newlines = '//hls-fpga-machine-learning insert final-round\n') %}
    {%- if cfg_get %}
        {%- for iclass in range(class_count) %}
            {%- set ns.newlines="%s %s   %s__voting_station_cl%d(in_class_stream[%d], out_class_stream[%d]);\n"|format(ns.newlines,intent,projectname,iclass,iclass,iclass) %}
        {%- endfor%}
    {%- endif%}
    {{ns.newlines}}
    while(
      {%- set newline = '//hls-fpga-machine-learning insert stream-check\n' %}
      {%- if cfg_get %}
          {%- set ns=namespace(out="%s%s      "|format(newline,intent)) %}
          {%- for iclass in range(class_count) %}
              {%- set ns.out = '%s!out_class_stream[%d].empty()'|format(ns.out,iclass) %}
              {%- if iclass < class_count - 1 %}
                  {%- set ns.out = '%s && '|format(ns.out) %}
              {%- else %}
              {%- endif %}
          {%- endfor %}
      {%- endif %}
      {{ns.out}}
    ) {

      for(int i = 0; i < BDT::fn_classes(n_classes); i++){
        class_score_s_t score;
        if (!out_class_stream[i].empty()) {
          out_class_stream[i] >> score;
          fout << score.data << " ";
        } else {
          fout << "NaN ";
        }
      }
      fout << std::endl;
    }

    fin.close();
  } else {
    std::cout << "CRITICAL: Unable to open input file." << std::endl;
	  return -1;
  }

  fout.close();
  ftrees.close();
  std::cout << "INFO: Saved inference results to file: " << RESULTS_LOG << std::endl;

  return 0;
}{{"\n"}}
